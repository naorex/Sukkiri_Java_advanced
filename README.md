# スッキリわかるJava入門 実践編 第4版

## Chapter1 インスタンスの基本操作

### Objectの3つの基本操作（新たにクラスを定義する際にやる事）

- `toString()` をオーバーライドして文字列表現を定義できる。
- `equals()` をオーバーライドして意味的に正しく等価を判定できるようにする。
- `hashCode()` を正しくオーバーライドしておくことで、ハッシュ値を用いるクラス（`HashMap`など）を利用できるようになる。

### 順序付け

- `Comparable` インタフェースを実装することで自然順序付けを定義でき、容易に並び替えできるようになる。
- `Comparator` インタフェースを実装し、自然順序以外の並び順を定義できる。

### 複製

- `Cloneable` インタフェースを実装した上で `clone()` をオーバーライドすることで、インスタンスを容易に複製できるようになる。
- インスタンスの複製方法には、インスタンスの参照先を考慮した深いコピーと、考慮しない浅いコピーがある。
- インスタンスを完全に複製するには、深いコピーが必要である。

### レコード

- `record` を用いると、フィールドとコンストラクタ・アクセサに加え、重要な `toString()`・`hashCode()`・`equals()` の3つのメソッドを適切にオーバーライドしたクラスを手軽に定義できる。
- `record` は継承を利用できないが、特にデータキャリアなどの実装用途には差し支えないことも多い。

## Chapter2 様々な種類のクラス

### 型安全

- 取り扱う変数に対して型による制約を与えることで、処理の安全性を向上させる考え方を、型安全という。

### ジェネリクス

- `< >` 記法を用いて、ジェネリクスを定義できる。
- ジェネリクスを用いたクラスやメソッドは、利用時に型を決定する。
- ジェネリクスによって汎用的なクラスやメソッドが提供できるとともに、利用時には型安全性を確保できる。

### 列挙型とシールクラス

- `enum` を用いて、インスタンスを列挙した集合を定義できる。
- シールクラスで継承先クラスを限定し、クラスを列挙した集合を定義できる。
- 列挙型やシールクラスは、`switch` 文の分岐に利用できる。

### インナークラス

- クラスの内部に定義できるインナークラスには、「メンバクラス」「ローカルクラス」「匿名クラス」の3種類がある。
- 匿名クラスは、その場限りのクラスを定義して使い捨てたい場面で活用する。

### null安全性

- `Optional` クラスをメソッドの戻り値の型として用いると、null安全性に配慮したプログラムを作成できる。
- 専用に準備されたクラスを用いて基本データ型にも適用できる。

## Chapter3

### 関数オブジェクト

- Java では関数を第1級オブジェクトとして扱う。
- 関数とは「入力・処理・出力 (IPO) を有する処理ロジック」である。
- クラス内に定義されたメソッドへの参照を、関数オブジェクトとして変数に代入できる。
- 1つの抽象メソッドのみを持つインターフェースは、関数インターフェースとして、関数を格納することができる。
- `java.util.function` パッケージには、代表的な関数インターフェースがあらかじめ準備されている。
- 引数として関数を受け取る関数を高階関数という。

### ラムダ式

- ラムダ式を用いることで、関数の実体をプログラム実行中に生成できる。
- ラムダ式にはさまざまな省略記法が用意されており、簡単な関数であればシンプルに記述することができる。
- ラムダ式は、自身が生成されたときに利用可能であった変数をラムダ式内部で利用できる。ただし、実質的に final な変数の読み取りに限られる。

### Stream API

- 1次元のデータ集合に対する処理は、高階関数を用いて宣言的に書き直せる。
- コレクションや配列から生成したストリームに対してメソッドを呼ぶことで、宣言的なデータ処理を実現できる。
- ストリームの中間処理メソッドは連鎖的に呼び出すことができる。
