# スッキリわかるJava入門 実践編 第4版

## Chapter1 インスタンスの基本操作

### Objectの3つの基本操作（新たにクラスを定義する際にやる事）

- `toString()` をオーバーライドして文字列表現を定義できる。
- `equals()` をオーバーライドして意味的に正しく等価を判定できるようにする。
- `hashCode()` を正しくオーバーライドしておくことで、ハッシュ値を用いるクラス（`HashMap`など）を利用できるようになる。

### 順序付け

- `Comparable` インタフェースを実装することで自然順序付けを定義でき、容易に並び替えできるようになる。
- `Comparator` インタフェースを実装し、自然順序以外の並び順を定義できる。

### 複製

- `Cloneable` インタフェースを実装した上で `clone()` をオーバーライドすることで、インスタンスを容易に複製できるようになる。
- インスタンスの複製方法には、インスタンスの参照先を考慮した深いコピーと、考慮しない浅いコピーがある。
- インスタンスを完全に複製するには、深いコピーが必要である。

### レコード

- `record` を用いると、フィールドとコンストラクタ・アクセサに加え、重要な `toString()`・`hashCode()`・`equals()` の3つのメソッドを適切にオーバーライドしたクラスを手軽に定義できる。
- `record` は継承を利用できないが、特にデータキャリアなどの実装用途には差し支えないことも多い。

## Chapter2 様々な種類のクラス

### 型安全

- 取り扱う変数に対して型による制約を与えることで、処理の安全性を向上させる考え方を、型安全という。

### ジェネリクス

- `< >` 記法を用いて、ジェネリクスを定義できる。
- ジェネリクスを用いたクラスやメソッドは、利用時に型を決定する。
- ジェネリクスによって汎用的なクラスやメソッドが提供できるとともに、利用時には型安全性を確保できる。

### 列挙型とシールクラス

- `enum` を用いて、インスタンスを列挙した集合を定義できる。
- シールクラスで継承先クラスを限定し、クラスを列挙した集合を定義できる。
- 列挙型やシールクラスは、`switch` 文の分岐に利用できる。

### インナークラス

- クラスの内部に定義できるインナークラスには、「メンバクラス」「ローカルクラス」「匿名クラス」の3種類がある。
- 匿名クラスは、その場限りのクラスを定義して使い捨てたい場面で活用する。

### null安全性

- `Optional` クラスをメソッドの戻り値の型として用いると、null安全性に配慮したプログラムを作成できる。
- 専用に準備されたクラスを用いて基本データ型にも適用できる。

## Chapter3 関数とラムダ式

### 関数オブジェクト

- Java では関数を第1級オブジェクトとして扱う。
- 関数とは「入力・処理・出力 (IPO) を有する処理ロジック」である。
- クラス内に定義されたメソッドへの参照を、関数オブジェクトとして変数に代入できる。
- 1つの抽象メソッドのみを持つインターフェースは、関数インターフェースとして、関数を格納することができる。
- `java.util.function` パッケージには、代表的な関数インターフェースがあらかじめ準備されている。
- 引数として関数を受け取る関数を高階関数という。

### ラムダ式

- ラムダ式を用いることで、関数の実体をプログラム実行中に生成できる。
- ラムダ式にはさまざまな省略記法が用意されており、簡単な関数であればシンプルに記述することができる。
- ラムダ式は、自身が生成されたときに利用可能であった変数をラムダ式内部で利用できる。ただし、実質的に final な変数の読み取りに限られる。

### Stream API

- 1次元のデータ集合に対する処理は、高階関数を用いて宣言的に書き直せる。
- コレクションや配列から生成したストリームに対してメソッドを呼ぶことで、宣言的なデータ処理を実現できる。
- ストリームの中間処理メソッドは連鎖的に呼び出すことができる。

## Chapter4 JVM 制御とリフレクション

### JVMに対する制御

- `System.exit()` はプログラムを終了させ、OSに終了コードを返す。
- `ProcessBuilder` クラスを利用して、外部プログラムを起動できる。
- `System.getProperty()` や `System.setProperty()` を利用して、システムプロパティの取得や設定ができる。
- ロケール、タイムゾーンに関する情報は、それぞれ、`java.util.Locale` クラス、`java.util.TimeZone` クラスを用いて管理することができる。
- `Runtime` クラスの `freeMemory()`、`totalMemory()`、`maxMemory()` を用いて、JVMのメモリの状況を取得できる。

### リフレクション

- `Class` クラスを用いて、型に関するさまざまな情報を取得できる。
- メンバに関する情報は、`Field`、`Method`、`Constructor` の各クラスのインスタンスとして取得できる。
- リフレクションAPIを用いて、クラスやメンバに対してどのような修飾 (public や final など) がされているかを調べることができる。
- リフレクションAPIを用いて、フィールドの値の読み書きやメソッドの実行を行うこともできる。
- リフレクションAPIを用いると、アクセス制御を回避してメンバを利用することができるが、むやみに使うべきものではない。

## Chapter5 非標準ライブラリの活用

### ライブラリとクラスパス

- 第三者が作成したクラスファイルを集めたものをライブラリという。
- ライブラリは通常 JAR ファイルの形式で提供される。
- ライブラリを利用するには、JAR ファイルをクラスパスに含める必要がある。

### 代表的なライブラリ

- Apache プロジェクトでは多数の優良なライブラリが公開されている。
- commons-lang は Java 言語の基本機能を強化するさまざまなクラスを備えている。
- Log4j 2 などのロガーライブラリを用いて、ログを画面やファイルに出力することができる。
- SLF4J のように「ほかのライブラリを利用するためのライブラリ」も存在する。

### オープンソースとライセンス

- オープンソース製品はソースコードが公開されており、自由に再頒布できる。
- オープンソースは基本的に非保証で現状のまま提供される。
- 故意か否かに関わらず、ライセンス違反を行うと重大なペナルティを科せられることがある。
- ライセンスとして問題のない利用かどうかは、安易に自分だけで判断しない。
- 特段の注意を要する代表的な OSS ライセンスとして、GPL と LGPL がある。

## Chapter6 ファイルの操作
